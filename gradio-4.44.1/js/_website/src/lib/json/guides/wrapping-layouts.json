{"guide": {"name": "wrapping-layouts", "category": "other-tutorials", "pretty_category": "Other Tutorials", "guide_index": null, "absolute_index": 73, "pretty_name": "Wrapping Layouts", "content": "# Wrapping Layouts\n\n\n\n## Introduction\n\nGradio features [blocks](https://www.gradio.app/docs/blocks) to easily layout applications. To use this feature, you need to stack or nest layout components and create a hierarchy with them. This isn't difficult to implement and maintain for small projects, but after the project gets more complex, this component hierarchy becomes difficult to maintain and reuse.\n\nIn this guide, we are going to explore how we can wrap the layout classes to create more maintainable and easy-to-read applications without sacrificing flexibility.\n\n## Example\n\nWe are going to follow the implementation from this Huggingface Space example:\n\n<gradio-app\nspace=\"WoWoWoWololo/wrapping-layouts\">\n</gradio-app>\n\n## Implementation\n\nThe wrapping utility has two important classes. The first one is the ```LayoutBase``` class and the other one is the ```Application``` class.\n\nWe are going to look at the ```render``` and ```attach_event``` functions of them for brevity. You can look at the full implementation from [the example code](https://huggingface.co/spaces/WoWoWoWololo/wrapping-layouts/blob/main/app.py).\n\nSo let's start with the ```LayoutBase``` class.\n\n### LayoutBase Class\n\n1. Render Function\n\n    Let's look at the ```render``` function in the ```LayoutBase``` class:\n\n```python\n# other LayoutBase implementations\n\ndef render(self) -> None:\n    with self.main_layout:\n        for renderable in self.renderables:\n            renderable.render()\n\n    self.main_layout.render()\n```\nThis is a little confusing at first but if you consider the default implementation you can understand it easily.\nLet's look at an example:\n\nIn the default implementation, this is what we're doing:\n\n```python\nwith Row():\n    left_textbox = Textbox(value=\"left_textbox\")\n    right_textbox = Textbox(value=\"right_textbox\")\n```\n\nNow, pay attention to the Textbox variables. These variables' ```render``` parameter is true by default. So as we use the ```with``` syntax and create these variables, they are calling the ```render``` function under the ```with``` syntax.\n\nWe know the render function is called in the constructor with the implementation from the ```gradio.blocks.Block``` class:\n\n```python\nclass Block:\n    # constructor parameters are omitted for brevity\n    def __init__(self, ...):\n        # other assign functions \n\n        if render:\n            self.render()\n```\n\nSo our implementation looks like this:\n\n```python\n# self.main_layout -> Row()\nwith self.main_layout:\n    left_textbox.render()\n    right_textbox.render()\n```\n\nWhat this means is by calling the components' render functions under the ```with``` syntax, we are actually simulating the default implementation.\n\nSo now let's consider two nested ```with```s to see how the outer one works. For this, let's expand our example with the ```Tab``` component:\n\n```python\nwith Tab():\n    with Row():\n        first_textbox = Textbox(value=\"first_textbox\")\n        second_textbox = Textbox(value=\"second_textbox\")\n```\n\nPay attention to the Row and Tab components this time. We have created the Textbox variables above and added them to Row with the ```with``` syntax. Now we need to add the Row component to the Tab component. You can see that the Row component is created with default parameters, so its render parameter is true, that's why the render function is going to be executed under the Tab component's ```with``` syntax.\n\nTo mimic this implementation, we need to call the ```render``` function of the ```main_layout``` variable after the ```with``` syntax of the ```main_layout``` variable.\n\nSo the implementation looks like this:\n\n```python\nwith tab_main_layout:\n    with row_main_layout:\n        first_textbox.render()\n        second_textbox.render()\n\n    row_main_layout.render()\n\ntab_main_layout.render()\n```\n\nThe default implementation and our implementation are the same, but we are using the render function ourselves. So it requires a little work.\n\nNow, let's take a look at the ```attach_event``` function.\n\n2. Attach Event Function\n\n    The function is left as not implemented because it is specific to the class, so each class has to implement its `attach_event` function.\n\n```python\n    # other LayoutBase implementations\n\n    def attach_event(self, block_dict: Dict[str, Block]) -> None:\n        raise NotImplementedError\n```\n\nCheck out the ```block_dict``` variable in the ```Application``` class's ```attach_event``` function.\n\n### Application Class\n\n1. Render Function\n\n```python\n    # other Application implementations\n\n    def _render(self):\n        with self.app:\n            for child in self.children:\n                child.render()\n\n        self.app.render()\n```\n\nFrom the explanation of the ```LayoutBase``` class's ```render``` function, we can understand the ```child.render``` part.\n\nSo let's look at the bottom part, why are we calling the ```app``` variable's ```render``` function? It's important to call this function because if we look at the implementation in the ```gradio.blocks.Blocks``` class, we can see that it is adding the components and event functions into the root component. To put it another way, it is creating and structuring the gradio application.\n\n2. Attach Event Function\n\n    Let's see how we can attach events to components:\n\n```python\n    # other Application implementations\n\n    def _attach_event(self):\n        block_dict: Dict[str, Block] = {}\n\n        for child in self.children:\n            block_dict.update(child.global_children_dict)\n\n        with self.app:\n            for child in self.children:\n                try:\n                    child.attach_event(block_dict=block_dict)\n                except NotImplementedError:\n                    print(f\"{child.name}'s attach_event is not implemented\")\n```\n\nYou can see why the ```global_children_list``` is used in the ```LayoutBase``` class from the example code. With this, all the components in the application are gathered into one dictionary, so the component can access all the components with their names.\n\nThe ```with``` syntax is used here again to attach events to components. If we look at the ```__exit__``` function in the ```gradio.blocks.Blocks``` class, we can see that it is calling the ```attach_load_events``` function which is used for setting event triggers to components. So we have to use the ```with``` syntax to trigger the ```__exit__``` function.\n\nOf course, we can call ```attach_load_events``` without using the ```with``` syntax, but the function needs a ```Context.root_block```, and it is set in the ```__enter__``` function. So we used the ```with``` syntax here rather than calling the function ourselves.\n\n## Conclusion\n\nIn this guide, we saw\n\n- How we can wrap the layouts\n- How components are rendered\n- How we can structure our application with wrapped layout classes\n\nBecause the classes used in this guide are used for demonstration purposes, they may still not be totally optimized or modular. But that would make the guide much longer!\n\nI hope this guide helps you gain another view of the layout classes and gives you an idea about how you can use them for your needs. See the full implementation of our example [here](https://huggingface.co/spaces/WoWoWoWololo/wrapping-layouts/blob/main/app.py).\n", "tags": ["LAYOUTS"], "spaces": [], "url": "/guides/wrapping-layouts/", "contributor": null}}