{"guide": {"name": "dynamic-apps-with-render-decorator", "category": "building-with-blocks", "pretty_category": "Building With Blocks", "guide_index": 4, "absolute_index": 10, "pretty_name": "Dynamic Apps With Render Decorator", "content": "# Dynamic Apps with the Render Decorator\n\nThe components and event listeners you define in a Blocks so far have been fixed - once the demo was launched, new components and listeners could not be added, and existing one could not be removed. \n\nThe `@gr.render` decorator introduces the ability to dynamically change this. Let's take a look. \n\n## Dynamic Number of Components\n\nIn the example below, we will create a variable number of Textboxes. When the user edits the input Textbox, we create a Textbox for each letter in the input. Try it out below:\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    input_text = gr.Textbox(label=\"input\")\n\n    @gr.render(inputs=input_text)\n    def show_split(text):\n        if len(text) == 0:\n            gr.Markdown(\"## No Input Provided\")\n        else:\n            for letter in text:\n                gr.Textbox(letter)\n\ndemo.launch()\n\n```\n<gradio-app space='gradio/render_split_simple'></gradio-app>\n\nSee how we can now create a variable number of Textboxes using our custom logic - in this case, a simple `for` loop. The `@gr.render` decorator enables this with the following steps:\n\n1. Create a function and attach the @gr.render decorator to it.\n2. Add the input components to the `inputs=` argument of @gr.render, and create a corresponding argument in your function for each component. This function will automatically re-run on any change to a component.\n3. Add all components inside the function that you want to render based on the inputs.\n\nNow whenever the inputs change, the function re-runs, and replaces the components created from the previous function run with the latest run. Pretty straightforward! Let's add a little more complexity to this app:\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    input_text = gr.Textbox(label=\"input\")\n    mode = gr.Radio([\"textbox\", \"button\"], value=\"textbox\")\n\n    @gr.render(inputs=[input_text, mode], triggers=[input_text.submit])\n    def show_split(text, mode):\n        if len(text) == 0:\n            gr.Markdown(\"## No Input Provided\")\n        else:\n            for letter in text:\n                if mode == \"textbox\":\n                    gr.Textbox(letter)\n                else:\n                    gr.Button(letter)\n\ndemo.launch()\n\n```\n<gradio-app space='gradio/render_split'></gradio-app>\n\nBy default, `@gr.render` re-runs are triggered by the `.load` listener to the app and the `.change` listener to any input component provided. We can override this by explicitly setting the triggers in the decorator, as we have in this app to only trigger on `input_text.submit` instead. \nIf you are setting custom triggers, and you also want an automatic render at the start of the app, make sure to add `demo.load` to your list of triggers.\n\n## Dynamic Event Listeners\n\nIf you're creating components, you probably want to attach event listeners to them as well. Let's take a look at an example that takes in a variable number of Textbox as input, and merges all the text into a single box.\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    text_count = gr.State(1)\n    add_btn = gr.Button(\"Add Box\")\n    add_btn.click(lambda x: x + 1, text_count, text_count)\n\n    @gr.render(inputs=text_count)\n    def render_count(count):\n        boxes = []\n        for i in range(count):\n            box = gr.Textbox(key=i, label=f\"Box {i}\")\n            boxes.append(box)\n\n        def merge(*args):\n            return \" \".join(args)\n\n        merge_btn.click(merge, boxes, output)\n\n    merge_btn = gr.Button(\"Merge\")\n    output = gr.Textbox(label=\"Merged Output\")\n\ndemo.launch()\n\n```\n<gradio-app space='gradio/render_merge_simple'></gradio-app>\n\nLet's take a look at what's happening here:\n\n1. The state variable `text_count` is keeping track of the number of Textboxes to create. By clicking on the Add button, we increase `text_count` which triggers the render decorator.\n2. Note that in every single Textbox we create in the render function, we explicitly set a `key=` argument. This key allows us to preserve the value of this Component between re-renders. If you type in a value in a textbox, and then click the Add button, all the Textboxes re-render, but their values aren't cleared because the `key=` maintains the the value of a Component across a render.\n3. We've stored the Textboxes created in a list, and provide this list as input to the merge button event listener. Note that **all event listeners that use Components created inside a render function must also be defined inside that render function**. The event listener can still reference Components outside the render function, as we do here by referencing `merge_btn` and `output` which are both defined outside the render function.\n\nJust as with Components, whenever a function re-renders, the event listeners created from the previous render are cleared and the new event listeners from the latest run are attached. \n\nThis allows us to create highly customizable and complex interactions! \n\n## Putting it Together\n\nLet's look at two examples that use all the features above. First, try out the to-do list app below: \n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n\n    tasks = gr.State([])\n    new_task = gr.Textbox(label=\"Task Name\", autofocus=True)\n\n    def add_task(tasks, new_task_name):\n        return tasks + [{\"name\": new_task_name, \"complete\": False}], \"\"\n\n    new_task.submit(add_task, [tasks, new_task], [tasks, new_task])\n\n    @gr.render(inputs=tasks)\n    def render_todos(task_list):\n        complete = [task for task in task_list if task[\"complete\"]]\n        incomplete = [task for task in task_list if not task[\"complete\"]]\n        gr.Markdown(f\"### Incomplete Tasks ({len(incomplete)})\")\n        for task in incomplete:\n            with gr.Row():\n                gr.Textbox(task['name'], show_label=False, container=False)\n                done_btn = gr.Button(\"Done\", scale=0)\n                def mark_done(task=task):\n                    task[\"complete\"] = True\n                    return task_list\n                done_btn.click(mark_done, None, [tasks])\n\n                delete_btn = gr.Button(\"Delete\", scale=0, variant=\"stop\")\n                def delete(task=task):\n                    task_list.remove(task)\n                    return task_list\n                delete_btn.click(delete, None, [tasks])\n\n        gr.Markdown(f\"### Complete Tasks ({len(complete)})\")\n        for task in complete:\n            gr.Textbox(task['name'], show_label=False, container=False)\n\ndemo.launch()\n\n```\n<gradio-app space='gradio/todo_list'></gradio-app>\n\nNote that almost the entire app is inside a single `gr.render` that reacts to the tasks `gr.State` variable. This variable is a nested list, which presents some complexity. If you design a `gr.render` to react to a list or dict structure, ensure you do the following:\n\n1. Any event listener that modifies a state variable in a manner that should trigger a re-render must set the state variable as an output. This lets Gradio know to check if the variable has changed behind the scenes. \n2. In a `gr.render`, if a variable in a loop is used inside an event listener function, that variable should be \"frozen\" via setting it to itself as a default argument in the function header. See how we have `task=task` in both `mark_done` and `delete`. This freezes the variable to its \"loop-time\" value.\n\nLet's take a look at one last example that uses everything we learned. Below is an audio mixer. Provide multiple audio tracks and mix them together.\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    track_count = gr.State(1)\n    add_track_btn = gr.Button(\"Add Track\")\n\n    add_track_btn.click(lambda count: count + 1, track_count, track_count)\n\n    @gr.render(inputs=track_count)\n    def render_tracks(count):\n        audios = []\n        volumes = []\n        with gr.Row():\n            for i in range(count):\n                with gr.Column(variant=\"panel\", min_width=200):\n                    gr.Textbox(placeholder=\"Track Name\", key=f\"name-{i}\", show_label=False)\n                    track_audio = gr.Audio(label=f\"Track {i}\", key=f\"track-{i}\")\n                    track_volume = gr.Slider(0, 100, value=100, label=\"Volume\", key=f\"volume-{i}\")\n                    audios.append(track_audio)\n                    volumes.append(track_volume)\n\n            def merge(data):\n                sr, output = None, None\n                for audio, volume in zip(audios, volumes):\n                    sr, audio_val = data[audio]\n                    volume_val = data[volume]\n                    final_track = audio_val * (volume_val / 100)\n                    if output is None:\n                        output = final_track\n                    else:\n                        min_shape = tuple(min(s1, s2) for s1, s2 in zip(output.shape, final_track.shape))\n                        trimmed_output = output[:min_shape[0], ...][:, :min_shape[1], ...] if output.ndim > 1 else output[:min_shape[0]]\n                        trimmed_final = final_track[:min_shape[0], ...][:, :min_shape[1], ...] if final_track.ndim > 1 else final_track[:min_shape[0]]\n                        output += trimmed_output + trimmed_final\n                return (sr, output)\n\n            merge_btn.click(merge, set(audios + volumes), output_audio)\n\n    merge_btn = gr.Button(\"Merge Tracks\")\n    output_audio = gr.Audio(label=\"Output\", interactive=False)\n\ndemo.launch()\n\n```\n<gradio-app space='gradio/audio_mixer'></gradio-app>\n\nTwo things to note in this app:\n1. Here we provide `key=` to all the components! We need to do this so that if we add another track after setting the values for an existing track, our input values to the existing track do not get reset on re-render.\n2. When there are lots of components of different types and arbitrary counts passed to an event listener, it is easier to use the set and dictionary notation for inputs rather than list notation. Above, we make one large set of all the input `gr.Audio` and `gr.Slider` components when we pass the inputs to the `merge` function. In the function body we query the component values as a dict.\n\nThe `gr.render` expands gradio capabilities extensively - see what you can make out of it! \n", "tags": [], "spaces": [], "url": "/guides/dynamic-apps-with-render-decorator/", "contributor": null}}